/*
 * Builds the Iconify-compatible package on disk using the data stored in SQLite.
 * This service is intentionally verbose to keep IO concerns away from the CLI module.
 */

import { join } from 'path';

import type { IconifyIcon } from '@iconify/utils';
import type { Database } from 'bun:sqlite';
import { spinner } from '@clack/prompts';

import { OUTPUT_PACKAGE_STRUCTURE } from '@/config/constants';
import type { KitConfig, StyleIconSet } from '@/types';
import { ensureDirectory } from '@/utils/fileSystem';
import { getIconsByStyle } from '@/services/databaseService';

export async function generatePackage(db: Database, config: KitConfig): Promise<number> {
  const s = spinner();
  s.start('Generating package structure...');

  try {
  await ensureDirectory(config.outputDir);
  await ensureDirectory(join(config.outputDir, OUTPUT_PACKAGE_STRUCTURE.src));
  await ensureDirectory(join(config.outputDir, OUTPUT_PACKAGE_STRUCTURE.dist));
  await ensureDirectory(join(config.outputDir, OUTPUT_PACKAGE_STRUCTURE.types));

    let totalIcons = 0;
    const styleSets: Record<string, StyleIconSet> = {};

    for (const style of config.selectedStyles) {
      const icons = getIconsByStyle(db, style);
      if (icons.length === 0) continue;

      const iconifyIcons: Record<string, IconifyIcon> = {};
      for (const icon of icons) {
        iconifyIcons[icon.name] = {
          body: icon.body,
          width: icon.width,
          height: icon.height,
          left: 0,
          top: 0,
          rotate: 0,
          vFlip: false,
          hFlip: false,
        };
      }

      const styleName = style.charAt(0).toUpperCase() + style.slice(1).replace(/-/g, '');
      const prefix = `${config.prefix}-${style}`;

      styleSets[style] = {
        prefix,
        icons: iconifyIcons,
        width: 512,
        height: 512,
        info: {
          name: `${config.iconSetName} ${styleName}`,
          total: icons.length,
          version: config.version,
          author: {
            name: 'FontAwesome to Iconify Converter',
          },
          license: {
            title: 'FontAwesome Pro License',
            spdx: 'UNLICENSED',
          },
        },
      };

      totalIcons += icons.length;
    }

    const exports: Record<string, unknown> = {
      '.': {
        types: './types/index.d.ts',
        import: './dist/index.js',
      },
    };

    const devDependencies: Record<string, string> = {
      bun: 'latest',
      typescript: '^5.0.0',
    };

    for (const style of config.selectedStyles) {
      const styleName = style.charAt(0).toUpperCase() + style.slice(1).replace(/-/g, '');
      const exportName = `fa${styleName}Set`;
      exports[`./${exportName}`] = {
        types: `./types/${exportName}.d.ts`,
        import: `./src/${exportName}.js`,
      };
    }

    const packageJson = {
      name: config.name,
      version: config.version,
      description: config.description,
      main: './dist/index.js',
      module: './dist/index.js',
      types: './types/index.d.ts',
      exports,
      private: true,
      keywords: ['iconify', 'icons', 'fontawesome', 'svg'],
      author: 'Generated by FontAwesome to Iconify Converter',
      license: 'UNLICENSED',
      scripts: {
        build: 'bun build ./src/index.ts --outdir ./dist',
        dev: 'bun run ./src/index.ts',
      },
      devDependencies,
      peerDependencies: {
        '@iconify/react': '^4.0.0',
      },
    };

    await Bun.write(join(config.outputDir, 'package.json'), JSON.stringify(packageJson, null, 2));

    const mainExports = config.selectedStyles
      .map((style: string) => {
        const styleName = style.charAt(0).toUpperCase() + style.slice(1).replace(/-/g, '');
        return `export { fa${styleName}Set } from './fa${styleName}Set.js';`;
      })
      .join('\n');

    const indexTs = `
// Auto-generated by FontAwesome to Iconify Converter
${mainExports}

// Re-export types
export type { IconifyIcon } from '@iconify/utils';
`;

    await Bun.write(join(config.outputDir, OUTPUT_PACKAGE_STRUCTURE.src, 'index.ts'), indexTs);

    for (const [style, iconSet] of Object.entries(styleSets)) {
      const styleName = style.charAt(0).toUpperCase() + style.slice(1).replace(/-/g, '');
      const exportName = `fa${styleName}Set`;

      const styleFile = `
// Auto-generated by FontAwesome to Iconify Converter
import iconSet from './${style}.json' with { type: 'json' };

export const ${exportName} = iconSet;
export default iconSet;
`;

      await Bun.write(join(config.outputDir, OUTPUT_PACKAGE_STRUCTURE.src, `${exportName}.ts`), styleFile);
      await Bun.write(join(config.outputDir, OUTPUT_PACKAGE_STRUCTURE.src, `${style}.json`), JSON.stringify(iconSet, null, 2));
    }

    let typesContent = `
// Auto-generated type definitions
import type { IconifyIcon } from '@iconify/utils';

export interface FontAwesomeProIconSet {
  prefix: string;
  icons: Record<string, IconifyIcon>;
  width: number;
  height: number;
  info: {
    name: string;
    total: number;
    version: string;
    author: {
      name: string;
    };
    license: {
      title: string;
      spdx: string;
    };
  };
}
`;

    for (const style of config.selectedStyles) {
      const styleName = style.charAt(0).toUpperCase() + style.slice(1).replace(/-/g, '');
      const exportName = `fa${styleName}Set`;
      typesContent += `
export declare const ${exportName}: FontAwesomeProIconSet;
`;
    }

    typesContent += `
export default FontAwesomeProIconSet;
`;

    await Bun.write(join(config.outputDir, OUTPUT_PACKAGE_STRUCTURE.types, 'index.d.ts'), typesContent);

    const usageExamples = config.selectedStyles
      .map((style: string) => {
        const styleName = style.charAt(0).toUpperCase() + style.slice(1).replace(/-/g, '');
        const exportName = `fa${styleName}Set`;
        return `### ${styleName} Style
\`\`\`typescript
import { ${exportName} } from '${config.name}';
import { Icon } from '@iconify/react';

// Use ${styleName} icons
<Icon icon="${config.prefix}-${style}:icon-name" />
\`\`\``;
      })
      .join('\n\n');

    const readme = `# ${config.name}

${config.description}

## ⚠️ Important Licensing Notice

This package contains FontAwesome Pro icons and is generated for **personal use only**.
- **DO NOT** publish this package to NPM or any public registry
- **DO NOT** distribute this package
- **DO NOT** use commercially without proper FontAwesome licensing
- Keep this package private and internal to your projects

## Installation

\`\`\`bash
bun install
\`\`\`

## Usage

${usageExamples}

## Development

\`\`\`bash
# Build the package
bun run build

# Development mode
bun run dev
\`\`\`

## FontAwesome Kit Download Instructions

1. Log in to your FontAwesome Pro account
2. Navigate to the "Kits" section
3. Create a new kit or select an existing one
4. Download the **Desktop** version (not Web)
5. Extract the kit to a directory
6. Place this converter script in the kit directory
7. Run: \`bunx fa-2-iconify\`

## License

UNLICENSED - FontAwesome Pro License applies
`;

    await Bun.write(join(config.outputDir, 'README.md'), readme);

    const gitignore = `node_modules/
dist/
*.log
.DS_Store
`;

    await Bun.write(join(config.outputDir, '.gitignore'), gitignore);

    const npmignore = `src/
.gitignore
*.ts
!dist/
!types/
`;

    await Bun.write(join(config.outputDir, '.npmignore'), npmignore);

    s.stop('Package structure generated successfully');
    return totalIcons;
  } catch (error) {
    s.stop('Failed to generate package structure');
    throw error;
  }
}
